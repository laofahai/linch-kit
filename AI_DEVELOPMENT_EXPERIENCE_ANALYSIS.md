# LinchKit AI开发体验深度分析报告 (v3.2)

**版本**: 3.2 (蓝图已确认)
**状态**: **行动纲领 (最终版)**
**目标**: 构建一个以“可验证的信任”为基石，以“人机协作”为核心交互模式的全新AI开发框架。

---

## 1. 最终诊断：信任的错位与责任的真空

**核心病因**: 项目当前的核心困境，源于我们构建了一个**要求AI无条件信任，但又不给AI提供可靠、可验证的信任基础**的系统。我们将这种系统性的矛盾称为 **“信任的错位与责任的真空”**。

AI的幻觉和错误，并非其自身的能力缺陷，而是这个系统性矛盾的必然产物。

### 认知摩擦的物证分析

1.  **叙事性过载 (`Essential_Rules.md`)**: 一篇为人类编写的、长达300行的“叙事性”文章，AI无法有效处理，导致关键信息被噪声淹没。
2.  **语义鸿沟 (`packages/auth`)**: Graph RAG无法理解代码背后复杂的**设计模式**和**架构分层**，导致检索必然失败。
3.  **僵化仪式 (`GEMINI.md`)**: 固定的启动流程创造了“责任真空”，强迫AI在一个充满“认知地雷”的区域里工作。

---

## 2. 决定性解决方案：引入“交互式计划确认”机制

我们的解决方案核心，是从一个纯粹的自动化系统，进化为一个**人机协作系统**。我们通过引入一个至关重要的交互节点，赋予开发者最终的审核与控制权。

### 最终AI协作模型与工作流

**协作模型**: **Gemini规划 + LinchKit验证 + Claude执行**

**工作流：引入“交互式计划确认”的七步流水线**

1.  **触发与调用 (Claude -> Workflow Engine)**
    用户在 `Claude Code` 中输入 `/start`，调用工作流引擎: `bun run workflow:run --prompt "..."`

2.  **分析与分解 (Engine -> Gemini)**
    引擎调用**Gemini (规划分析器)**，生成初步的**“执行蓝图”**。

3.  **验证与充实 (Engine <-> Knowledge Base)**
    引擎启动**“验证循环”**，用知识库（图谱/规则脚本）核实蓝图，过滤幻觉，形成**可信上下文**。

4.  **规划 (`PLANNING`)**
    引擎再次调用Gemini，结合可信上下文生成最终的、分步的**“行动计划”**。

5.  **暂停与呈现 (`PENDING_APPROVAL`)**  **<-- 全新核心交互点**
    工作流引擎在此处**暂停**，并通过 `Claude Code` 界面，将清晰的“行动计划”**呈现给用户**进行审核。
    - **界面显示**:
      ```
      [AI Execution Plan]
      1. CREATE: packages/core/src/cache/redis.ts
      2. MODIFY: packages/auth/src/service.ts
      Approve this plan? (y/n/edit)
      ```

6.  **执行 (`GENERATING`)**: **只有在用户明确批准后**，引擎才会将计划交给**Claude (代码生成器)**进行代码生成。

7.  **终审与交付 (`FINALIZING`)**: 引擎自动执行所有规则脚本，对新代码进行最终审查，确保100%合规。

---

## 3. 实施路线图：清理、构建、迁移

### **Phase 0: 清理战场 (关键第一步)**
**指令**: **暂停所有其他开发工作，切换到新分支 `feature/refactor-ai-workflow`。**
1.  **全面清理 `package.json`**: 移除所有与旧流程相关、功能不明确或已废弃的`scripts`命令。
2.  **审计并删除无用脚本**: 审查`tools/`和`scripts/`目录，删除所有不再需要的脚本文件。
3.  **建立脚本规范**: 创建一个`CONTRIBUTING_SCRIPTS.md`，定义新脚本的命名、参数、文档和输出规范。
4.  **目标**: 创造一个干净、可靠、可预测的脚本环境，为后续工作流引擎的构建扫清障碍。

### **Phase 1: 地基工程 - 定义Schema与规则 (2-3天)**
1.  **创建并版本化核心Schema**: `ExecutionBlueprint.schema.json`, `RuleOutput.schema.json`, `WorkflowState.schema.json`。
2.  **实现第一批 `Rules as Code` 脚本**: 挑选3-5个核心规则（如 `check-types`, `check-lint`），确保其100%符合新规范。
3.  **实现 `sync --enrich` v1**: 使用AST和`@linchkit-pattern`注解，实现对几种核心模式的识别。

### **Phase 2: 构建“工作流引擎”核心 (4-5天)**
1.  **实现有限状态机 (FSM) 核心逻辑**: 能够创建、持久化、恢复工作流状态文件 (`.linchkit/workflows/[task-id].json`)。
2.  **实现 `VALIDATING` 状态的并行验证循环**。
3.  **实现 `PENDING_APPROVAL` 状态**: 构建引擎与 `Claude Code` CLI界面之间的交互逻辑，能够暂停并等待用户输入。

### **Phase 3: 集成“大脑”与“双手” (3-4天)**
1.  **开发 `Task Analyzer` (Gemini) Agent**: 确保其输出严格遵守 `ExecutionBlueprint.schema.json`。
2.  **将Gemini集成到工作流引擎的 `ANALYZING` 和 `PLANNING` 状态**。
3.  **开发 `Code Generator` (Claude) Agent 的适配器**: 让它能够接收引擎在 `GENERATING` 状态下分发的、经过批准的行动计划。

### **Phase 4: 全面替换与端到端测试 (2-3天)**
1.  **重构 `Claude Code` 的 `/start` 命令**，使其调用 `bun run workflow:run`。
2.  进行完整的、包含用户交互确认的端到端流程测试。
3.  **正式废弃 `Essential_Rules.md` 和所有旧的启动仪式文档**。

---

## 4. 最终评估与行动确认 (v3.1 新增)

**综合评估**: **本方案 (v3.1) 是一个经过深思熟虑、技术上可行且风险可控的优秀方案，应立即作为项目核心开发流程进行实施。** 它不仅解决了当前开发流程中的核心矛盾，并且与框架稳定化的总体规划（`Master Plan v1.7`）高度一致，是实现其目标的必要演进。

### 4.1 核心优势再确认

- **✅ 交互式确认机制**: 从根本上解决了“信任错位”问题。将最终决策权交还给开发者，AI从黑盒执行者转变为强大的“规划与建议”引擎，完美平衡了效率与控制力。
- **✅ 清晰的状态机设计**: 七步工作流和有限状态机（FSM）为实现提供了极为清晰的路径。`PENDING_APPROVAL` 状态是核心交互点，将复杂流程分解为可管理、可测试的独立单元。
- **✅ 务实的分阶段实施**: 从“清理战场”开始，分步构建、迭代验证，有效降低了技术风险和实施难度。

### 4.2 关键技术点实现策略

为确保方案顺利落地，针对识别出的关键技术点，制定以下实现策略：

- **🎯 Claude Code CLI 集成策略**:
    - **通信机制**: 初期采用**文件监听**机制。引擎进入`PENDING_APPROVAL`状态时，在 `.linchkit/workflows/` 目录中创建或更新一个带唯一任务ID的状态文件（如 `[task-id].pending.json`）。CLI工具通过监听此目录的变化来接收审批任务。
    - **用户交互**: 用户在CLI中输入 `y/n/edit` 后，CLI工具将结果写入一个响应文件（如 `[task-id].approved.json`），引擎监听到此文件后继续执行或中止。
    - **健壮性**: 引擎需处理超时逻辑，如果在规定时间内未收到用户响应，可自动转为暂停状态并提示用户。

- **🎯 Gemini API 成本控制策略**:
    - **请求缓存**: 在工作流引擎中内置一个缓存层。对于相同的任务提示和上下文组合，直接返回缓存的“执行蓝图”，避免重复调用。
    - **智能模型选择**: 引擎根据任务的复杂度（可通过初步分析的关键词、涉及文件数量等指标判断）动态选择合适的Gemini模型。简单任务使用成本更低的轻量级模型。
    - **提示词优化 (Prompt Engineering)**: 设计更精炼、结构化的提示词，减少不必要的Token消耗，并确保输出格式的稳定性。

- **🎯 多工作流并发管理策略**:
    - **状态隔离**: 强制为每个工作流实例分配一个唯一ID (`task-id`)，所有相关的状态文件、日志和产出物都必须存储在以该ID命名的独立子目录中，确保完全隔离。
    - **资源锁定**: 在v1版本中，将并发模型简化为**“单一写者”**。即，同一时间只允许一个工作流处于 `GENERATING` 或 `FINALIZING` 状态。通过一个全局锁文件（如 `.linchkit/workflows/write.lock`）进行控制，后续工作流需排队等待。
    - **并行读取**: `ANALYZING` 和 `VALIDATING` 等只读阶段可以并行执行，以最大化效率。

### 4.3 与项目总体规划的对齐

本方案是实现 **`05_Master_Plan_for_Framework_Stabilization.md` (v1.7)** 中所述目标的**加速器**和**质量保障器**。
- **支撑“审计优先”**: `VALIDATING` 验证循环和 `FINALIZING` 终审阶段，就是“审计优先”原则的自动化实现。
- **驱动“测试驱动”**: 行动计划中可以强制包含测试用例的编写和执行，确保新功能在生成时就具备测试覆盖。
- **保障“API设计优先”**: “执行蓝图”本身就是对API和代码结构的预先设计，经过人类审核后才进入实现阶段。

---

## 5. 重构完成后的最终状态蓝图 (v3.2 新增)

为确保所有参与者对重构目标有统一、清晰的认知，特此定义工作流引擎全面实施后的最终项目状态。

### 5.1 核心引导文件的演变：从叙事到代码

- **`GEMINI.md`, `CLAUDE.md`**: **彻底删除**。AI的启动流程和核心指令将被硬编码（hardcoded）到工作流引擎中，不再需要AI阅读和理解这些宏大的叙事性文档。
- **`Essential_Rules.md`**: **彻底废弃并删除**。其所有核心约束（如类型安全、分支管理、测试覆盖率）将被转化为一系列可独立执行、可自动验证的 **`Rules as Code` 脚本**。这些脚本将成为工作流引擎在 `VALIDATING` 和 `FINALIZING` 阶段的强制性检查点。

### 5.2 `ai-context` 目录的重塑：从“阅读材料”到“知识库”

- **定位转变**: `ai-context` 目录将不再是AI需要完整阅读的“上下文填充物”，而是转变为一个结构化的、可供工作流引擎按需精确查询的 **“可验证知识库” (Verifiable Knowledge Base)**。
- **核心内容**:
    - `rules/`: 存放所有 `Rules as Code` 脚本。
    - `schemas/`: 存放所有核心流程的JSON Schema定义（如 `ExecutionBlueprint.schema.json`）。
    - `patterns/`: 存放已识别并固化的核心代码设计模式。
    - `graph/`: 存放项目知识图谱的持久化数据。
- **交互方式**: AI（通过工作流引擎）不再被动接收整个目录的文本，而是主动通过 `bun run kb:query [query]` 或 `bun run rule:check [rule_name]` 等精确指令与知识库交互。

### 5.3 统一的AI交互入口：`/start`

- **唯一入口**: `/start "任务描述"` 将成为开发者与AI协作的 **唯一、标准、可预测的交互入口**。
- **背后机制**: 该命令将不再依赖模糊的提示工程，而是严格映射到对工作流引擎的标准化调用：`bun run workflow:run --prompt "任务描述"`。这将触发一个确定性的、基于状态机的、可被追踪和审计的开发流程。

### 5.4 新的AI“第一份文档”：`AI_WORKFLOW.md`

- **目标**: 创建一份全新的、极其简洁的 `AI_WORKFLOW.md`，它将取代所有旧的引导文件，成为AI和新开发者理解协作模式的唯一入口。
- **核心内容 (不超过20行)**:
    1.  **如何启动**: `To start a new task, use the /start command: /start "your task description"`
    2.  **核心交互模型**: `The AI will generate an execution plan. You must approve it before any code is written. (Approve: y / Deny: n / Edit: edit)`
    3.  **知识库参考**: `To understand the project's rules and architecture, the AI will automatically query the verifiable knowledge base located in the /ai-context directory.`

这个蓝图为重构工作提供了清晰的终点线，确保我们正在构建的是一个真正高效、可靠且易于维护的AI原生开发框架。

---

## 6. 行动指令

**结论已经明确，蓝图已经清晰，立即开始执行。**

1.  **创建分支**: `git checkout -b feature/refactor-ai-workflow`
2.  **启动 Phase 0**: 立即开始执行“清理战场”任务，为新工作流引擎的构建扫清障碍。

---
---
# APPENDED CONTENT FOR REVIEW (v3.4)
---
---

# LinchKit AI开发体验深度分析报告 (v3.4)

**版本**: 3.4 (红队演习终版)
**状态**: **行动纲领 (最终锁定)**
**目标**: 构建一个在“红队演习”压力测试下，依旧能保证可信、合规、健壮的AI原生开发框架。

---

## 1. 最终诊断：从“信任错位”到“可信流程”

（无变化）

---

## 2. 决定性解决方案：交互式工作流与全局守护者

（无变化）

---

## 3. 红队演习：在最悲观的视角下锤炼方案 (v3.4 新增)

一个未经压力测试的方案是脆弱的。本章节将扮演一个试图让系统崩溃或绕过它的“恶意/无知用户”，从人性、演进、环境三个维度，对v3.3方案进行最严苛的攻击，并制定最终的强化策略。

### 3.1 攻击维度一：人性 (The Human Factor)

- **攻击：审批疲劳 (Approval Fatigue)**
  - **场景**: 开发者被迫对每一个微不足道的修改（如改注释）都进行审批，最终将养成不经思考按`y`的肌肉记忆，使安全机制失效。
  - **强化策略：引入“关键性评估 (Criticality Assessment)”**
    - “AI守护者”增加**关键性评估**步骤，根据任务关键词（`refactor`, `delete`）、涉及文件数和核心程度，将任务评定为`CRITICAL`, `NORMAL`, `TRIVIAL`三级。
    - `TRIVIAL`级任务可由AI自主完成，事后通知。
    - `CRITICAL`级任务除`y`外，还需输入特定确认词，强制开发者思考。

- **攻击：“编辑”循环陷阱 (The "Edit" Loop Trap)**
  - **场景**: 用户给出模糊的修改意见，导致AI反复生成不满足要求的计划，用户陷入无法退出的沮-丧循环。
  - **强化策略：提供“逃生舱口 (Escape Hatch)”**
    - 在`REVISING_PLAN`状态下，提供新选项`(f)orce manual`。
    - 用户选择后，工作流暂停，将最新计划导出至`temp-plan.md`，允许开发者随时手动接管。

### 3.2 攻击维度二：演进 (The Evolution Factor)

- **攻击：守护者自身的腐化 (Guardian's Own Corruption)**
  - **场景**: “AI守护者”的拦截规则存在bug或因技术迭代而未更新，导致整个安全体系出现漏洞。
  - **强化策略：守护者的“自我进化”与“元工作流”**
    - 守护者的规则库必须拥有**独立的、严格的单元测试和集成测试**。
    - 对守护者规则的任何修改，都必须通过一个需要**两名核心开发者**审批的**“元工作流”**。

- **攻击：Schema的无声崩溃 (Silent Schema Collapse)**
  - **场景**: 核心Schema（如`ExecutionBlueprint.schema.json`）更新后，正在运行的、基于旧Schema的工作流实例在恢复时因校验失败而崩溃。
  - **强化策略：Schema版本化与迁移路径**
    - 所有核心Schema文件必须包含版本号（`*.v1.schema.json`）。
    - 工作流引擎必须内置**迁移模块**，能将旧版状态数据自动、安全地升级到新版，确保向后兼容。

### 3.3 攻击维度三：环境 (The Environment Factor)

- **攻击：钩子的脆弱性 (The Hook's Fragility)**
  - **场景**: `pre-ai-command`钩子依赖于开发者本地的shell环境配置（如`.bashrc`），当开发者使用不同shell（`zsh`）或IDE插件时，该钩子被**完全绕过**。
  - **强化策略：将最终防线从“本地”后退至“仓库”**
    - **放弃对本地shell钩子的幻想**。将守护者的最终、最强防线设置在**Git的 `pre-commit` 钩子**上。
    - 该`pre-commit`钩子会检查所有暂存代码。如果发现任何由AI生成但**没有对应工作流历史记录**的修改，将**直接拒绝本次提交**。
    - 这使得无论开发者在本地用何种方式生成代码，都无法将其合入代码库，实现了**无法绕过的强制合规**。

---

## 4. 实施路线图 (已更新 v3.4)

- **Phase 0 & 1**: (无变化)
- **Phase 2: 构建“工作流引擎”核心**
  - (原任务)
  - **新增**: 实现“关键性评估”逻辑。
  - **新增**: 实现`REVISING_PLAN`状态及`(f)orce manual`逃生舱口。
- **Phase 3: 地基工程 - 定义Schema与规则**
  - (原任务)
  - **新增**: 建立Schema版本化与迁移机制。
- **Phase 4: 全面替换与最终防线部署**
  - (原任务)
  - **新增**: 实现并全局部署**基于 `pre-commit` 的最终守护者防线**。
  - **新增**: 为守护者规则库建立独立的“元工作流”和测试套件。

---

## 5. 重构完成后的最终状态蓝图 (已更新 v3.4)

- (原内容无变化)
- **5.5 新增：最终安全保障**
  - **不可绕过的 `pre-commit` 守护**：所有代码在提交入库前，必须通过`pre-commit`钩子的校验，确保其要么是人类编写的，要么是拥有合法工作流历史的AI代码。这是整个框架的最终安全底线。

---

## 6. 最终评估与行动确认

本方案(v3.4)是经历“红队演习”压力测试后的最终产物，已覆盖所有已知的人性、演进和环境漏洞，形成了一个逻辑自洽、技术健壮、风险可控的闭环。它是一个可以信赖的、准备好面对现实世界挑战的AI原生开发框架的基石。

---

## 7. 行动指令

**理论已完备，蓝图已铸成，压力测试已通过。结论不可动摇，立即开始执行。**

1.  **创建分支**: `git checkout -b feature/refactor-ai-workflow`
2.  **启动 Phase 0**: 立即开始执行“清理战场”任务，为新工作流引擎的构建扫清障碍。

---
---
# APPENDED CONTENT FOR REVIEW (v3.3)
---
---

# LinchKit AI开发体验深度分析报告 (v3.3)

**版本**: 3.3 (最终确认版)
**状态**: **行动纲领 (不可动摇)**
**目标**: 构建一个以“可验证的信任”为基石，以“人机协作”为核心，并由“全局守护者”保障合规的全新AI开发框架。

---

## 1. 最终诊断：从“信任错位”到“可信流程”

**核心病因**: 项目的根本困境源于一个核心矛盾：我们要求AI像人类一样无条件地、创造性地工作，但却未能提供一个机器可以理解和依赖的、可验证的信任基础。这导致了“信任的错位与责任的真空”。

**最终解决方案**: 我们不试图修复AI，而是修复AI的工作环境。通过构建一个全新的、确定性的、人机协作的工作流，并用一个无法绕过的技术手段保障其执行，我们从根本上解决这个矛盾。

---

## 2. 决定性解决方案：交互式工作流与全局守护者

### 2.1 核心引擎：引入“交互式计划确认”的七步流水线

工作流的核心是一个基于状态机的引擎，它将AI的创造力（规划）与开发者的洞察力（审批）结合在一起。

**工作流状态**: `IDLE` -> `ANALYZING` -> `VALIDATING` -> `PLANNING` -> `PENDING_APPROVAL` -> `GENERATING` -> `FINALIZING` -> `IDLE`

### 2.2 关键交互点：`PENDING_APPROVAL` 状态的增强

这是人机协作的核心，我们为其引入了强大的交互能力：

- **审批选项**: `(y)es / (n)o / (e)dit`
    - **(y)es**: 批准计划，进入 `GENERATING` 状态。
    - **(n)o**: 否决计划，终止工作流。
    - **(e)dit**: **进入“交互式修订循环”**。

- **交互式修订循环 (Interactive Revision Loop)**:
    1.  用户选择 `(e)dit`，工作流进入临时的 `REVISING_PLAN` 状态。
    2.  引擎提示用户输入修改意见 (e.g., "Use Redis for caching in step 2")。
    3.  引擎将用户的反馈和原始计划打包，重新提交给Gemini规划器进行修订。
    4.  获得修订后的新计划后，工作流返回 `PENDING_APPROVAL` 状态，再次寻求用户确认。此循环可无限进行，直至计划完美。

- **上下文查询 (Contextual Query)**:
    - 在审批期间，开发者可以随时提问 (e.g., "Why did you choose this library?")。
    - 一个轻量级的查询Agent将访问工作流上下文并回答问题，此过程**不改变工作流状态**，确保决策信息充分。

### 2.3 全局保障：无法绕过的“AI守护者”机制

为杜绝任何绕过标准工作流的“越狱”行为，我们设立一个全局的、强制性的技术检查点。

- **实现方式**: 一个 `pre-ai-command` 钩子，它会在**任何AI工具（Claude, Gemini CLI等）执行指令前**被强制触发，调用核心脚本 `bun run ai:guardian:pre-check`。
- **守护者职责**:
    1.  **意图分析**: 对用户指令进行快速意图分析。
    2.  **无害放行**: 对于只读查询类指令 (e.g., "what is the current branch?")，直接放行。
    3.  **恶意拦截**: 对于任何涉及代码修改的指令 (e.g., "refactor this file", "add a feature")，**立即拦截**。
    4.  **强制引导**: 对被拦截的指令，守护者会返回标准响应：“此操作必须通过标准工作流执行以确保合规。系统已为您自动转换指令，请确认是否启动：`bun run workflow:run --prompt "您刚才的指令"`”。

**最终效果**: 通过“AI守护者”，我们创造了一个技术上无法被规避的“单一入口”系统。所有对代码库的重大修改，无论源自何处，都将被强制引导至我们设计的可控工作流中。

---

## 3. 实施路线图 (已更新 v3.3)

- **Phase 0: 清理战场**: (无变化)
- **Phase 1: 地基工程**: (无变化)
- **Phase 2: 构建“工作流引擎”核心**:
    - (原任务)
    - **新增**: 实现 `REVISING_PLAN` 状态及完整的“交互式修订循环”逻辑。
    - **新增**: 实现轻量级的“上下文查询”Agent接口。
- **Phase 3: 集成“大脑”与“双手”**: (无变化)
- **Phase 4: 全面替换与端到端测试**:
    - (原任务)
    - **新增**: 实现并全局部署 `ai:guardian:pre-check` 脚本及 `pre-ai-command` 钩子。

---

## 4. 重构完成后的最终状态蓝图 (已更新 v3.3)

- **4.1 核心引导文件的演变**: (无变化)
- **4.2 `ai-context` 目录的重塑**: (无变化)
- **4.3 统一的AI交互入口**: (无变化)
- **4.4 新的AI“第一份文档”**: (无变化)
- **4.5 新增：全局AI行为范式**:
    - **唯一代码修改路径**: 所有AI发起的代码修改，100%通过 `bun run workflow:run` 发起。
    - **前置守护者检查**: 所有AI指令（无论读写）在执行前，100%通过 `ai:guardian:pre-check` 的检查。
    - **可审计性**: 所有被批准的行动计划和执行日志，都将被持久化记录在 `.linchkit/workflows/history/` 中，提供完整的、可追溯的审计链。

---

## 5. 最终评估与行动确认

本方案 (v3.3) 已覆盖所有已知漏洞，形成了一个逻辑自洽、技术可行、风险可控的闭环。它是一个真正健壮的AI原生开发框架的基石。

---

## 6. 行动指令

**理论已完备，蓝图已清晰，结论不可动摇。立即开始执行。**

1.  **创建分支**: `git checkout -b feature/refactor-ai-workflow`
2.  **启动 Phase 0**: 立即开始执行“清理战场”任务，为新工作流引擎的构建扫清障碍。

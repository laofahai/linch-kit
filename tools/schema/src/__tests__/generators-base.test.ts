/**
 * @linch-kit/schema Base Generator 测试套件
 */

import { describe, it, expect, mock, beforeEach } from 'bun:test'
import { BaseGenerator, CodeGenerator, createGenerator, GeneratorRegistry, quickGenerate } from '../generators/base'
import { defineEntity } from '../core/entity'
import { defineField } from '../core/field'

const { string, number } = defineField
import type { Generator, GeneratorContext, GeneratedFile } from '../types'

// 测试用生成器
class TestGenerator extends BaseGenerator {
  readonly name = 'test'

  async generate(context: GeneratorContext): Promise<GeneratedFile[]> {
    this.validateEntities(context.entities as any)

    const content = context.entities.map(e => `Entity: ${e.name}`).join('\n')
    return [this.createGeneratedFile('test.txt', content, 'other')]
  }

  protected getFileExtension(): string {
    return '.txt'
  }
}

// 另一个测试用生成器
class AnotherTestGenerator extends BaseGenerator {
  readonly name = 'another'

  async generate(context: GeneratorContext): Promise<GeneratedFile[]> {
    return [this.createGeneratedFile('another.txt', 'Another content', 'other')]
  }

  protected getFileExtension(): string {
    return '.txt'
  }
}

describe('BaseGenerator', () => {
  describe('基础功能', () => {
    it('应该实现抽象方法', () => {
      const generator = new TestGenerator()

      expect(generator.name).toBe('test')
      expect(generator.generate).toBeInstanceOf(Function)
    })

    it('应该生成文件头部注释', () => {
      const generator = new TestGenerator()
      const header = (generator as any).generateHeader()

      expect(header).toContain('Generated by @linch-kit/schema')
      expect(header).toContain('Do not edit this file manually')
      expect(header).toContain('Generated at:')
    })

    it('应该格式化内容', () => {
      const generator = new TestGenerator()
      const content = '  test content  '
      const formatted = (generator as any).formatContent(content)

      expect(formatted).toBe('test content\n')
    })

    it('应该创建生成文件对象', () => {
      const generator = new TestGenerator()
      const file = (generator as any).createGeneratedFile('test.txt', 'content', 'other')

      expect(file.path).toBe('test.txt')
      expect(file.type).toBe('other')
      expect(file.content).toContain('Generated by @linch-kit/schema')
      expect(file.content).toContain('content')
    })
  })

  describe('实体验证', () => {
    it('应该验证实体数组不为空', () => {
      const generator = new TestGenerator()

      expect(() => {
        ;(generator as any).validateEntities([])
      }).toThrow('No entities provided for code generation')
    })

    it('应该验证实体有名称', () => {
      const generator = new TestGenerator()
      const invalidEntity = { fields: { name: string() } }

      expect(() => {
        ;(generator as any).validateEntities([invalidEntity])
      }).toThrow('Entity name is required')
    })

    it('应该验证实体有字段', () => {
      const generator = new TestGenerator()
      const invalidEntity = { name: 'User', fields: {} }

      expect(() => {
        ;(generator as any).validateEntities([invalidEntity])
      }).toThrow('Entity User has no fields defined')
    })

    it('应该通过有效实体验证', () => {
      const generator = new TestGenerator()
      const validEntity = { name: 'User', fields: { name: string() } }

      expect(() => {
        ;(generator as any).validateEntities([validEntity])
      }).not.toThrow()
    })
  })

  describe('字符串转换工具', () => {
    it('应该转换为snake_case', () => {
      const generator = new TestGenerator()

      expect((generator as any).toSnakeCase('UserProfile')).toBe('user_profile')
      expect((generator as any).toSnakeCase('XMLHttpRequest')).toBe('x_m_l_http_request')
      expect((generator as any).toSnakeCase('user')).toBe('user')
      expect((generator as any).toSnakeCase('User')).toBe('user')
    })

    it('应该转换为camelCase', () => {
      const generator = new TestGenerator()

      expect((generator as any).toCamelCase('user_profile')).toBe('userProfile')
      expect((generator as any).toCamelCase('User_Profile')).toBe('user_Profile')
      expect((generator as any).toCamelCase('user')).toBe('user')
    })

    it('应该转换为PascalCase', () => {
      const generator = new TestGenerator()

      expect((generator as any).toPascalCase('user_profile')).toBe('UserProfile')
      expect((generator as any).toPascalCase('user')).toBe('User')
      expect((generator as any).toPascalCase('User')).toBe('User')
    })

    it('应该转换为kebab-case', () => {
      const generator = new TestGenerator()

      expect((generator as any).toKebabCase('UserProfile')).toBe('user-profile')
      expect((generator as any).toKebabCase('XMLHttpRequest')).toBe('x-m-l-http-request')
      expect((generator as any).toKebabCase('user')).toBe('user')
      expect((generator as any).toKebabCase('User')).toBe('user')
    })
  })
})

describe('CodeGenerator', () => {
  describe('基础功能', () => {
    it('应该创建代码生成器', () => {
      const user = defineEntity('User', {
        name: string(),
      })

      const generator = new CodeGenerator({
        entities: [user],
        outputDir: './generated',
      })

      expect(generator).toBeInstanceOf(CodeGenerator)
    })

    it('应该在没有实体时抛出错误', () => {
      expect(() => {
        new CodeGenerator({
          entities: [],
          outputDir: './generated',
        })
      }).toThrow('No entities provided for code generation')
    })
  })

  describe('生成器管理', () => {
    it('应该注册生成器', () => {
      const user = defineEntity('User', {
        name: string(),
      })

      const codeGen = new CodeGenerator({
        entities: [user],
        outputDir: './generated',
      })

      const generator = new TestGenerator()
      codeGen.registerGenerator(generator)

      expect(codeGen.getGenerator('test')).toBe(generator)
    })

    it('应该注册多个生成器', () => {
      const user = defineEntity('User', {
        name: string(),
      })

      const codeGen = new CodeGenerator({
        entities: [user],
        outputDir: './generated',
      })

      const generator1 = new TestGenerator()
      const generator2 = new AnotherTestGenerator()

      codeGen.registerGenerators([generator1, generator2])

      expect(codeGen.getGenerator('test')).toBe(generator1)
      expect(codeGen.getGenerator('another')).toBe(generator2)
    })

    it('应该获取所有生成器', () => {
      const user = defineEntity('User', {
        name: string(),
      })

      const codeGen = new CodeGenerator({
        entities: [user],
        outputDir: './generated',
      })

      const generator1 = new TestGenerator()
      const generator2 = new AnotherTestGenerator()

      codeGen.registerGenerators([generator1, generator2])

      const allGenerators = codeGen.getAllGenerators()
      expect(allGenerators).toHaveLength(2)
      expect(allGenerators).toContain(generator1)
      expect(allGenerators).toContain(generator2)
    })
  })

  describe('代码生成', () => {
    it('应该生成代码', async () => {
      const user = defineEntity('User', {
        name: string(),
        age: number(),
      })

      const codeGen = new CodeGenerator({
        entities: [user],
        outputDir: './generated',
      })

      const generator = new TestGenerator()
      codeGen.registerGenerator(generator)

      const files = await codeGen.generate()

      expect(files).toHaveLength(1)
      expect(files[0].path).toBe('test.txt')
      expect(files[0].content).toContain('Entity: User')
    })

    it('应该生成特定类型的代码', async () => {
      const user = defineEntity('User', {
        name: string(),
      })

      const codeGen = new CodeGenerator({
        entities: [user],
        outputDir: './generated',
      })

      const generator = new TestGenerator()
      codeGen.registerGenerator(generator)

      const files = await codeGen.generateByType('test')

      expect(files).toHaveLength(1)
      expect(files[0].path).toBe('test.txt')
    })

    it('应该在生成器未找到时抛出错误', async () => {
      const user = defineEntity('User', {
        name: string(),
      })

      const codeGen = new CodeGenerator({
        entities: [user],
        outputDir: './generated',
      })

      await expect(codeGen.generateByType('nonexistent')).rejects.toThrow(
        'Generator nonexistent not found'
      )
    })

    it('应该处理生成器错误', async () => {
      const user = defineEntity('User', {
        name: string(),
      })

      const codeGen = new CodeGenerator({
        entities: [user],
        outputDir: './generated',
      })

      // 创建一个会抛出错误的生成器
      const errorGenerator: Generator = {
        name: 'error',
        async generate() {
          throw new Error('Test error')
        },
      }

      codeGen.registerGenerator(errorGenerator)

      await expect(codeGen.generate()).rejects.toThrow(
        'Generator error failed: Test error'
      )
    })
  })

  describe('钩子系统', () => {
    it('应该执行生成前钩子', async () => {
      const user = defineEntity('User', {
        name: string(),
      })

      const beforeGenerate = mock(() => Promise.resolve())

      const codeGen = new CodeGenerator({
        entities: [user],
        outputDir: './generated',
        hooks: {
          beforeGenerate,
        },
      })

      const generator = new TestGenerator()
      codeGen.registerGenerator(generator)

      await codeGen.generate()

      expect(beforeGenerate).toHaveBeenCalledTimes(1)
    })

    it('应该执行文件生成后钩子', async () => {
      const user = defineEntity('User', {
        name: string(),
      })

      const afterFileGenerated = mock(() => Promise.resolve())

      const codeGen = new CodeGenerator({
        entities: [user],
        outputDir: './generated',
        hooks: {
          afterFileGenerated,
        },
      })

      const generator = new TestGenerator()
      codeGen.registerGenerator(generator)

      await codeGen.generate()

      expect(afterFileGenerated).toHaveBeenCalledTimes(1)
    })

    it('应该执行生成完成钩子', async () => {
      const user = defineEntity('User', {
        name: string(),
      })

      const afterGenerate = mock(() => Promise.resolve())

      const codeGen = new CodeGenerator({
        entities: [user],
        outputDir: './generated',
        hooks: {
          afterGenerate,
        },
      })

      const generator = new TestGenerator()
      codeGen.registerGenerator(generator)

      await codeGen.generate()

      expect(afterGenerate).toHaveBeenCalledTimes(1)
    })
  })

  describe('文件系统生成', () => {
    it('应该在没有输出目录时抛出错误', async () => {
      const user = defineEntity('User', {
        name: string(),
      })

      const codeGen = new CodeGenerator({
        entities: [user],
        outputDir: undefined,
      })

      const generator = new TestGenerator()
      codeGen.registerGenerator(generator)

      await expect(codeGen.generateToFiles()).rejects.toThrow(
        'Output directory not specified'
      )
    })

    it('应该打印生成的文件列表', async () => {
      const user = defineEntity('User', {
        name: string(),
      })

      const codeGen = new CodeGenerator({
        entities: [user],
        outputDir: './generated',
      })

      const generator = new TestGenerator()
      codeGen.registerGenerator(generator)

      // Mock console.log
      const originalLog = console.log
      const logMock = mock()
      console.log = logMock

      await codeGen.generateToFiles()

      expect(logMock).toHaveBeenCalledWith('Generated 1 files:')
      expect(logMock).toHaveBeenCalledWith('  - test.txt (other)')

      // 恢复原始 console.log
      console.log = originalLog
    })
  })
})

describe('createGenerator', () => {
  it('应该创建代码生成器', () => {
    const user = defineEntity('User', {
      name: string(),
    })

    const generator = createGenerator({
      entities: [user],
      outputDir: './generated',
    })

    expect(generator).toBeInstanceOf(CodeGenerator)
  })
})

describe('GeneratorRegistry', () => {
  // 重置注册表
  beforeEach(() => {
    // 清空注册表
    ;(GeneratorRegistry as any).generators.clear()
  })

  describe('注册和创建', () => {
    it('应该注册生成器类', () => {
      GeneratorRegistry.register('test', TestGenerator)

      const names = GeneratorRegistry.getRegisteredNames()
      expect(names).toContain('test')
    })

    it('应该创建生成器实例', () => {
      GeneratorRegistry.register('test', TestGenerator)

      const generator = GeneratorRegistry.create('test')
      expect(generator).toBeInstanceOf(TestGenerator)
    })

    it('应该在生成器未注册时抛出错误', () => {
      expect(() => {
        GeneratorRegistry.create('nonexistent')
      }).toThrow('Generator nonexistent not registered')
    })

    it('应该创建所有注册的生成器', () => {
      GeneratorRegistry.register('test', TestGenerator)
      GeneratorRegistry.register('another', AnotherTestGenerator)

      const generators = GeneratorRegistry.createAll()
      expect(generators).toHaveLength(2)
      expect(generators[0]).toBeInstanceOf(TestGenerator)
      expect(generators[1]).toBeInstanceOf(AnotherTestGenerator)
    })
  })
})

describe('quickGenerate', () => {
  // 重置注册表
  beforeEach(() => {
    ;(GeneratorRegistry as any).generators.clear()
    GeneratorRegistry.register('test', TestGenerator)
  })

  it('应该快速生成代码', async () => {
    const user = defineEntity('User', {
      name: string(),
    })

    const files = await quickGenerate({
      entities: [user],
      generators: ['test'],
      outputDir: './generated',
    })

    expect(files).toHaveLength(1)
    expect(files[0].path).toBe('test.txt')
  })

  it('应该支持钩子', async () => {
    const user = defineEntity('User', {
      name: string(),
    })

    const beforeGenerate = mock(() => Promise.resolve())

    const files = await quickGenerate({
      entities: [user],
      generators: ['test'],
      outputDir: './generated',
      hooks: {
        beforeGenerate,
      },
    })

    expect(files).toHaveLength(1)
    expect(beforeGenerate).toHaveBeenCalledTimes(1)
  })
})
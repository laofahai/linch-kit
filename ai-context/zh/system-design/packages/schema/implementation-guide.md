# @linch-kit/schema å®ç°æŒ‡å—

> **æ–‡æ¡£ç±»å‹**: å®ç°ç»†èŠ‚  
> **é€‚ç”¨åœºæ™¯**: æ·±åº¦å®šåˆ¶å’Œæ‰©å±•

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ¨¡å—ç»„ç»‡
```
src/
â”œâ”€â”€ core/               # æ ¸å¿ƒSchemaç³»ç»Ÿ
â”‚   â”œâ”€â”€ entity.ts       # å®ä½“å®šä¹‰
â”‚   â”œâ”€â”€ field.ts        # å­—æ®µç±»å‹ç³»ç»Ÿ
â”‚   â””â”€â”€ registry.ts     # Schemaæ³¨å†Œè¡¨
â”œâ”€â”€ generators/         # ä»£ç ç”Ÿæˆå™¨
â”‚   â”œâ”€â”€ prisma.ts       # Prisma Schemaç”Ÿæˆ
â”‚   â”œâ”€â”€ types.ts        # TypeScriptç±»å‹ç”Ÿæˆ
â”‚   â”œâ”€â”€ zod.ts          # ZodéªŒè¯å™¨ç”Ÿæˆ
â”‚   â””â”€â”€ api.ts          # APIè·¯ç”±ç”Ÿæˆ
â”œâ”€â”€ validation/         # éªŒè¯ç³»ç»Ÿ
â”‚   â”œâ”€â”€ rules.ts        # éªŒè¯è§„åˆ™
â”‚   â”œâ”€â”€ engine.ts       # éªŒè¯å¼•æ“
â”‚   â””â”€â”€ i18n.ts         # å›½é™…åŒ–éªŒè¯æ¶ˆæ¯
â”œâ”€â”€ migration/          # è¿ç§»ç³»ç»Ÿ
â”‚   â”œâ”€â”€ differ.ts       # Schemaå·®å¼‚æ£€æµ‹
â”‚   â”œâ”€â”€ generator.ts    # è¿ç§»ä»£ç ç”Ÿæˆ
â”‚   â””â”€â”€ executor.ts     # è¿ç§»æ‰§è¡Œ
â””â”€â”€ plugins/           # æ’ä»¶ç³»ç»Ÿ
    â”œâ”€â”€ permissions.ts  # æƒé™é›†æˆæ’ä»¶
    â””â”€â”€ i18n.ts        # å›½é™…åŒ–æ’ä»¶
```

## ğŸ¯ æ ¸å¿ƒå®ç°ç­–ç•¥

### åŸºäºæˆç†Ÿåº“è€Œéé‡å¤é€ è½®å­

#### Zodé›†æˆ (éªŒè¯æ ¸å¿ƒ)
```typescript
import { z } from 'zod' // ä½¿ç”¨ Zod ä½œä¸ºéªŒè¯æ ¸å¿ƒï¼Œè€Œä¸æ˜¯è‡ªå·±å®ç°

/**
 * è®¾è®¡åŸåˆ™ï¼š
 * - ä½¿ç”¨ Zod ä½œä¸ºéªŒè¯å¼•æ“ï¼Œé¿å…é‡å¤å®ç°éªŒè¯é€»è¾‘
 * - åŸºäº Zod æ„å»ºé«˜çº§æŠ½è±¡ï¼Œä½†ä¿æŒåº•å±‚å…¼å®¹æ€§
 * - æ”¯æŒ Zod çš„æ‰€æœ‰ç‰¹æ€§å’Œç”Ÿæ€
 */

class SchemaFieldBuilder {
  static string(options?: StringFieldOptions): FieldDefinition {
    // åŸºäº Zod æ„å»ºï¼Œè€Œä¸æ˜¯è‡ªå·±å®ç°å­—ç¬¦ä¸²éªŒè¯
    const zodSchema = z.string()
    
    if (options?.min) zodSchema.min(options.min)
    if (options?.max) zodSchema.max(options.max)
    if (options?.pattern) zodSchema.regex(options.pattern)
    if (options?.email) zodSchema.email()
    if (options?.url) zodSchema.url()
    
    return {
      type: 'string',
      zodSchema, // ä¿ç•™åŸå§‹ Zod schema ä»¥ä¾¿æ‰©å±•
      ...options
    }
  }
  
  static number(options?: NumberFieldOptions): FieldDefinition {
    const zodSchema = z.number()
    
    if (options?.min !== undefined) zodSchema.min(options.min)
    if (options?.max !== undefined) zodSchema.max(options.max)
    if (options?.int) zodSchema.int()
    if (options?.positive) zodSchema.positive()
    
    return {
      type: 'number',
      zodSchema,
      ...options
    }
  }
  
  static enum<T extends string>(values: T[], options?: EnumFieldOptions): FieldDefinition {
    // ç›´æ¥ä½¿ç”¨ Zod çš„ enum åŠŸèƒ½
    const zodSchema = z.enum(values as [T, ...T[]])
    
    return {
      type: 'enum',
      zodSchema,
      enumValues: values,
      ...options
    }
  }
}
```

#### Prismaé›†æˆ (ORMæ ¸å¿ƒ)
```typescript
import { DMMF } from '@prisma/generator-helper' // ä½¿ç”¨ Prisma çš„ç”Ÿæ€å·¥å…·

/**
 * Prisma Schema ç”Ÿæˆå™¨ - åŸºäº Prisma ç”Ÿæ€
 * 
 * è®¾è®¡åŸåˆ™ï¼š
 * - ä½¿ç”¨ @prisma/generator-helper è€Œä¸æ˜¯æ‰‹åŠ¨è§£æ
 * - é›†æˆ Prisma çš„æœ€ä½³å®è·µå’Œçº¦å®š
 * - æ”¯æŒ Prisma çš„æ‰€æœ‰å­—æ®µç±»å‹å’Œå…³ç³»
 */
class PrismaGenerator {
  private static readonly PRISMA_TYPE_MAPPING = {
    string: 'String',
    number: 'Int',
    boolean: 'Boolean',
    date: 'DateTime',
    uuid: 'String', // é…åˆ @id @default(uuid())
    email: 'String',
    url: 'String',
    json: 'Json',
  } as const
  
  static generateSchema(entities: Entity[]): string {
    const models = entities.map(entity => this.generateModel(entity))
    
    return `
// Generated by @linch-kit/schema
// Do not edit manually

generator client {
  provider = "prisma-client-js"
  output   = "./generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

${models.join('\n\n')}
`
  }
  
  private static generateModel(entity: Entity): string {
    const fields = Object.entries(entity.fields)
      .map(([name, field]) => this.generateField(name, field))
      .join('\n  ')
    
    return `model ${entity.name} {
  id        String   @id @default(uuid())
  ${fields}
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  @@map("${entity.options.tableName || this.toSnakeCase(entity.name)}")
}`
  }
  
  private static generateField(name: string, field: FieldDefinition): string {
    const prismaType = this.PRISMA_TYPE_MAPPING[field.type] || 'String'
    const nullable = field.required ? '' : '?'
    const unique = field.unique ? ' @unique' : ''
    const defaultValue = field.default ? ` @default(${this.formatDefault(field.default)})` : ''
    
    return `${name} ${prismaType}${nullable}${unique}${defaultValue}`
  }
}
```

#### TypeScriptä»£ç ç”Ÿæˆ (åŸºäºts-morph)
```typescript
import { Project, StructureKind } from 'ts-morph' // ä½¿ç”¨ ts-morph ç”ŸæˆTSä»£ç 

/**
 * TypeScript ä»£ç ç”Ÿæˆå™¨ - åŸºäº ts-morph
 * 
 * è®¾è®¡åŸåˆ™ï¼š
 * - ä½¿ç”¨ ts-morph è€Œä¸æ˜¯å­—ç¬¦ä¸²æ‹¼æ¥ç”Ÿæˆä»£ç 
 * - ç¡®ä¿ç”Ÿæˆçš„ä»£ç ç¬¦åˆ TypeScript æœ€ä½³å®è·µ
 * - æ”¯æŒ JSDoc æ³¨é‡Šå’Œç±»å‹å¯¼å‡º
 */
class TypeScriptGenerator {
  private project = new Project()
  
  generateTypes(entities: Entity[]): GeneratedFile[] {
    const files: GeneratedFile[] = []
    
    // ç”Ÿæˆå®ä½“ç±»å‹æ–‡ä»¶
    for (const entity of entities) {
      const file = this.project.createSourceFile(
        `types/${entity.name.toLowerCase()}.ts`,
        '',
        { overwrite: true }
      )
      
      // ç”ŸæˆåŸºç¡€æ¥å£
      file.addInterface({
        kind: StructureKind.Interface,
        name: entity.name,
        isExported: true,
        docs: [`Generated entity interface for ${entity.name}`],
        properties: this.generateInterfaceProperties(entity)
      })
      
      // ç”Ÿæˆ Create/Update è¾“å…¥ç±»å‹
      file.addTypeAlias({
        kind: StructureKind.TypeAlias,
        name: `Create${entity.name}Input`,
        isExported: true,
        type: `Omit<${entity.name}, 'id' | 'createdAt' | 'updatedAt'>`
      })
      
      file.addTypeAlias({
        kind: StructureKind.TypeAlias,
        name: `Update${entity.name}Input`,
        isExported: true,
        type: `Partial<Create${entity.name}Input>`
      })
      
      files.push({
        path: file.getFilePath(),
        content: file.getFullText(),
        type: 'types'
      })
    }
    
    // ç”Ÿæˆç´¢å¼•æ–‡ä»¶
    const indexFile = this.project.createSourceFile('types/index.ts', '', { overwrite: true })
    entities.forEach(entity => {
      indexFile.addExportDeclaration({
        moduleSpecifier: `./${entity.name.toLowerCase()}`
      })
    })
    
    files.push({
      path: indexFile.getFilePath(),
      content: indexFile.getFullText(),
      type: 'types'
    })
    
    return files
  }
  
  private generateInterfaceProperties(entity: Entity) {
    return [
      { name: 'id', type: 'string' },
      ...Object.entries(entity.fields).map(([name, field]) => ({
        name,
        type: this.mapFieldTypeToTypeScript(field),
        hasQuestionToken: !field.required,
        docs: field.description ? [field.description] : undefined
      })),
      { name: 'createdAt', type: 'Date' },
      { name: 'updatedAt', type: 'Date' }
    ]
  }
  
  private mapFieldTypeToTypeScript(field: FieldDefinition): string {
    const typeMap = {
      string: 'string',
      number: 'number',
      boolean: 'boolean',
      date: 'Date',
      uuid: 'string',
      email: 'string',
      url: 'string',
      json: 'Record<string, unknown>',
      enum: field.enumValues ? field.enumValues.map(v => `'${v}'`).join(' | ') : 'string'
    }
    
    return typeMap[field.type] || 'unknown'
  }
}
```

## ğŸ”„ Schemaè¿ç§»ç³»ç»Ÿ

### åŸºäºç°æœ‰è¿ç§»å·¥å…·
```typescript
import { diff } from 'deep-diff' // ä½¿ç”¨æˆç†Ÿçš„å¯¹è±¡å·®å¼‚æ£€æµ‹åº“

/**
 * Schema è¿ç§»ç®¡ç†å™¨ - åŸºäºæˆç†Ÿå·®å¼‚æ£€æµ‹
 * 
 * è®¾è®¡åŸåˆ™ï¼š
 * - ä½¿ç”¨ deep-diff åº“æ£€æµ‹ Schema å˜åŒ–ï¼Œè€Œä¸æ˜¯è‡ªå·±å®ç°
 * - é›†æˆ Prisma çš„è¿ç§»ç³»ç»Ÿ
 * - æä¾›å®‰å…¨çš„è¿ç§»é¢„è§ˆå’Œå›æ»š
 */
class SchemaMigrationManager {
  async generateMigration(
    oldEntities: Entity[], 
    newEntities: Entity[]
  ): Promise<Migration> {
    // ä½¿ç”¨ deep-diff æ£€æµ‹å˜åŒ–ï¼Œè€Œä¸æ˜¯æ‰‹åŠ¨æ¯”è¾ƒ
    const differences = diff(
      this.normalizeEntities(oldEntities),
      this.normalizeEntities(newEntities)
    )
    
    if (!differences || differences.length === 0) {
      throw new Error('No schema changes detected')
    }
    
    const operations = this.convertDifferencesToOperations(differences)
    const sql = await this.generateMigrationSQL(operations)
    
    return {
      id: this.generateMigrationId(),
      timestamp: new Date(),
      operations,
      sql,
      checksum: this.calculateChecksum(sql)
    }
  }
  
  private convertDifferencesToOperations(differences: Diff[]): MigrationOperation[] {
    return differences.map(diff => {
      switch (diff.kind) {
        case 'N': // æ–°å¢
          return this.createAddOperation(diff)
        case 'D': // åˆ é™¤
          return this.createDeleteOperation(diff)
        case 'E': // ç¼–è¾‘
          return this.createEditOperation(diff)
        case 'A': // æ•°ç»„å˜åŒ–
          return this.createArrayOperation(diff)
        default:
          throw new Error(`Unsupported diff kind: ${diff.kind}`)
      }
    })
  }
  
  async validateMigration(migration: Migration): Promise<ValidationResult> {
    // ä½¿ç”¨ Prisma çš„éªŒè¯åŠŸèƒ½
    try {
      await this.prismaMigrate.validate(migration.sql)
      return { valid: true }
    } catch (error) {
      return { 
        valid: false, 
        errors: [error.message],
        suggestions: this.generateFixSuggestions(error)
      }
    }
  }
}
```

## ğŸ”Œ æ’ä»¶ç³»ç»Ÿé›†æˆ

### æƒé™æ’ä»¶å®ç°
```typescript
import { PermissionChecker } from '@linch-kit/auth' // ä¾èµ– auth åŒ…

/**
 * Schemaæƒé™æ’ä»¶ - é›†æˆ @linch-kit/auth
 * 
 * è®¾è®¡åŸåˆ™ï¼š
 * - ä¾èµ– @linch-kit/auth åŒ…çš„æƒé™ç³»ç»Ÿï¼Œä¸é‡å¤å®ç°
 * - åœ¨ Schema å±‚é¢å®šä¹‰æƒé™è§„åˆ™
 * - ç”Ÿæˆè¿è¡Œæ—¶æƒé™æ£€æŸ¥ä»£ç 
 */
class SchemaPermissionPlugin {
  static applyPermissions(entity: Entity): Entity {
    if (!entity.options.permissions) {
      return entity
    }
    
    // ä¸ºæ¯ä¸ªå­—æ®µæ·»åŠ æƒé™æ£€æŸ¥è£…é¥°å™¨
    const enhancedFields = Object.entries(entity.fields).reduce(
      (acc, [name, field]) => {
        acc[name] = {
          ...field,
          permissionCheck: this.generateFieldPermissionCheck(field.permissions)
        }
        return acc
      },
      {} as Record<string, FieldDefinition>
    )
    
    return {
      ...entity,
      fields: enhancedFields,
      permissionCheck: this.generateEntityPermissionCheck(entity.options.permissions)
    }
  }
  
  private static generateFieldPermissionCheck(permissions?: FieldPermissions) {
    if (!permissions) return undefined
    
    return async (user: User, operation: 'read' | 'write') => {
      const rules = permissions[operation]
      if (!rules) return true
      
      // ä½¿ç”¨ @linch-kit/auth çš„æƒé™æ£€æŸ¥å™¨
      return await PermissionChecker.checkFieldPermission(user, rules)
    }
  }
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### å¢é‡ä»£ç ç”Ÿæˆ
```typescript
import { createHash } from 'crypto' // ä½¿ç”¨ Node.js å†…ç½®cryptoæ¨¡å—

/**
 * å¢é‡ä»£ç ç”Ÿæˆå™¨ - ä¼˜åŒ–æ„å»ºæ€§èƒ½
 * 
 * è®¾è®¡åŸåˆ™ï¼š
 * - åªé‡æ–°ç”Ÿæˆå˜åŒ–çš„æ–‡ä»¶
 * - ä½¿ç”¨æ–‡ä»¶å“ˆå¸Œæ£€æµ‹å˜åŒ–
 * - æ”¯æŒå¹¶è¡Œç”Ÿæˆ
 */
class IncrementalGenerator {
  private cache = new Map<string, string>() // æ–‡ä»¶å“ˆå¸Œç¼“å­˜
  
  async generateIncremental(entities: Entity[]): Promise<GeneratedFile[]> {
    const generators = [
      new TypeScriptGenerator(),
      new PrismaGenerator(),
      new ZodGenerator(),
      new APIGenerator()
    ]
    
    // å¹¶è¡Œç”Ÿæˆï¼Œåªå¤„ç†å˜åŒ–çš„å®ä½“
    const results = await Promise.all(
      generators.map(async generator => {
        const changedEntities = await this.getChangedEntities(entities, generator.name)
        if (changedEntities.length === 0) {
          return []
        }
        
        return await generator.generate(changedEntities)
      })
    )
    
    return results.flat()
  }
  
  private async getChangedEntities(entities: Entity[], generatorName: string): Promise<Entity[]> {
    const changed: Entity[] = []
    
    for (const entity of entities) {
      const currentHash = this.calculateEntityHash(entity)
      const cacheKey = `${generatorName}:${entity.name}`
      const previousHash = this.cache.get(cacheKey)
      
      if (currentHash !== previousHash) {
        changed.push(entity)
        this.cache.set(cacheKey, currentHash)
      }
    }
    
    return changed
  }
  
  private calculateEntityHash(entity: Entity): string {
    // ä½¿ç”¨ç¨³å®šçš„åºåˆ—åŒ–æ¥è®¡ç®—å“ˆå¸Œ
    const normalized = JSON.stringify(entity, Object.keys(entity).sort())
    return createHash('sha256').update(normalized).digest('hex')
  }
}
```

## ğŸŒ å›½é™…åŒ–é›†æˆ

### åŸºäºi18nextç”Ÿæ€
```typescript
import i18next from 'i18next' // ä½¿ç”¨æˆç†Ÿçš„i18nåº“

/**
 * Schemaå›½é™…åŒ–æ’ä»¶ - åŸºäº i18next
 * 
 * è®¾è®¡åŸåˆ™ï¼š
 * - ä½¿ç”¨ i18next è€Œä¸æ˜¯è‡ªå·±å®ç°å›½é™…åŒ–
 * - æ”¯æŒåŠ¨æ€è¯­è¨€åˆ‡æ¢
 * - é›†æˆéªŒè¯æ¶ˆæ¯å›½é™…åŒ–
 */
class SchemaI18nPlugin {
  static createI18nField(config: I18nFieldConfig): FieldDefinition {
    return {
      type: 'i18n',
      locales: config.locales,
      fallbackLocale: config.fallback || 'en',
      zodSchema: z.record(
        z.enum(config.locales as [string, ...string[]]),
        z.string()
      ),
      required: config.required || [],
      
      // ä½¿ç”¨ i18next çš„æ’å€¼åŠŸèƒ½
      getTranslation: (locale: string, fallback?: string) => {
        return i18next.t(`${config.namespace}.${config.key}`, {
          lng: locale,
          fallbackLng: fallback || config.fallback
        })
      }
    }
  }
  
  static generateI18nValidationMessages(entities: Entity[]): Record<string, Record<string, string>> {
    const messages: Record<string, Record<string, string>> = {}
    
    entities.forEach(entity => {
      Object.entries(entity.fields).forEach(([fieldName, field]) => {
        if (field.validation) {
          field.validation.forEach(rule => {
            const key = `${entity.name}.${fieldName}.${rule.type}`
            
            // ä¸ºæ¯ç§æ”¯æŒçš„è¯­è¨€ç”ŸæˆéªŒè¯æ¶ˆæ¯
            i18next.options.supportedLngs?.forEach(locale => {
              if (!messages[locale]) messages[locale] = {}
              messages[locale][key] = this.generateValidationMessage(rule, locale)
            })
          })
        }
      })
    })
    
    return messages
  }
}
```

## ğŸ”— åŒ…ä¾èµ–å…³ç³»åˆ†æ

### ä¾èµ–è¾“å…¥
```typescript
// æ¥è‡ª @linch-kit/core çš„ä¾èµ–
import { PluginSystem, Logger, I18nManager } from '@linch-kit/core'

// å¤–éƒ¨æˆç†Ÿåº“ä¾èµ–
import { z } from 'zod'              // éªŒè¯å¼•æ“
import { Project } from 'ts-morph'    // TypeScriptä»£ç ç”Ÿæˆ
import { diff } from 'deep-diff'      // å¯¹è±¡å·®å¼‚æ£€æµ‹
import i18next from 'i18next'         // å›½é™…åŒ–
```

### ä¾èµ–è¾“å‡º (è¢«å…¶ä»–åŒ…ä½¿ç”¨)
```typescript
// ä¸»è¦å¯¼å‡ºç»™ @linch-kit/crud, @linch-kit/trpc, @linch-kit/auth
export { Entity, FieldDefinition, defineEntity }     // ç»™ crud/auth åŒ…ä½¿ç”¨
export { CodeGenerator, GeneratedFile }              // ç»™æ„å»ºå·¥å…·ä½¿ç”¨
export { ValidationRule, MigrationManager }          // ç»™æ•°æ®åº“åŒ…ä½¿ç”¨
```

### å¾ªç¯ä¾èµ–æ£€æŸ¥
```typescript
/**
 * âœ… æ— å¾ªç¯ä¾èµ–éªŒè¯
 * 
 * @linch-kit/schema çš„ä½ç½®ï¼š
 * - ä¾èµ–ï¼šcore (âœ… åˆç†)
 * - è¢«ä¾èµ–ï¼šauth, crud, trpc (âœ… åˆç†)
 * - ä¸åº”è¯¥ä¾èµ–ï¼šauth, crud, trpc (âŒ ä¼šé€ æˆå¾ªç¯)
 * 
 * æƒé™é›†æˆç­–ç•¥ï¼š
 * - å®šä¹‰æƒé™è§„åˆ™æ¥å£ï¼Œä½†ä¸å®ç°æƒé™æ£€æŸ¥é€»è¾‘
 * - æƒé™æ£€æŸ¥ç”± @linch-kit/auth åŒ…å®ç°
 * - é€šè¿‡æ’ä»¶ç³»ç»Ÿæ³¨å…¥æƒé™æ£€æŸ¥åŠŸèƒ½
 */

// âœ… æ­£ç¡®ï¼šå®šä¹‰æ¥å£ï¼Œä¸å®ç°é€»è¾‘
export interface PermissionRule {
  role?: string
  condition?: string
  context?: Record<string, unknown>
}

// âŒ é”™è¯¯ï¼šä¸åº”è¯¥åœ¨ schema åŒ…ä¸­å¯¼å…¥ auth åŒ…
// import { PermissionChecker } from '@linch-kit/auth' // è¿™ä¼šé€ æˆå¾ªç¯ä¾èµ–
```

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### åŸºäºç°æœ‰æµ‹è¯•å·¥å…·
```typescript
import { describe, it, expect } from 'vitest'  // ä½¿ç”¨ vitest è€Œä¸æ˜¯è‡ªå»ºæµ‹è¯•
import { faker } from '@faker-js/faker'        // ä½¿ç”¨ faker ç”Ÿæˆæµ‹è¯•æ•°æ®

/**
 * Schema æµ‹è¯•å¥—ä»¶ - åŸºäºæˆç†Ÿæµ‹è¯•å·¥å…·
 */
describe('Schema System', () => {
  describe('Entity Definition', () => {
    it('should create valid entity with Zod validation', () => {
      const User = defineEntity('User', {
        fields: {
          name: { type: 'string', required: true },
          email: { type: 'email', required: true, unique: true },
          age: { type: 'number', min: 0, max: 120 }
        }
      })
      
      // æµ‹è¯•ç”Ÿæˆçš„ Zod schema
      const validData = {
        name: faker.person.fullName(),
        email: faker.internet.email(),
        age: faker.number.int({ min: 18, max: 65 })
      }
      
      expect(() => User.zodSchema.parse(validData)).not.toThrow()
    })
    
    it('should generate correct TypeScript types', async () => {
      const entities = [createTestEntity()]
      const generator = new TypeScriptGenerator()
      
      const files = await generator.generateTypes(entities)
      
      expect(files).toHaveLength(2) // entity file + index file
      expect(files[0].content).toContain('export interface User')
      expect(files[0].content).toContain('export type CreateUserInput')
    })
  })
  
  describe('Code Generation Performance', () => {
    it('should generate code incrementally', async () => {
      const entities = Array.from({ length: 100 }, (_, i) => 
        createTestEntity(`Entity${i}`)
      )
      
      const generator = new IncrementalGenerator()
      
      // ç¬¬ä¸€æ¬¡ç”Ÿæˆ
      const start1 = performance.now()
      await generator.generateIncremental(entities)
      const time1 = performance.now() - start1
      
      // ç¬¬äºŒæ¬¡ç”Ÿæˆï¼ˆåº”è¯¥æ›´å¿«ï¼Œå› ä¸ºæ²¡æœ‰å˜åŒ–ï¼‰
      const start2 = performance.now()
      await generator.generateIncremental(entities)
      const time2 = performance.now() - start2
      
      expect(time2).toBeLessThan(time1 * 0.1) // åº”è¯¥å¿«90%ä»¥ä¸Š
    })
  })
})
```

## ğŸ“ˆ æ€§èƒ½åŸºå‡†

### ä»£ç ç”Ÿæˆæ€§èƒ½è¦æ±‚
- **å•ä¸ªå®ä½“ç”Ÿæˆæ—¶é—´**: < 50ms
- **100ä¸ªå®ä½“æ‰¹é‡ç”Ÿæˆ**: < 5ç§’
- **å¢é‡ç”Ÿæˆä¼˜åŒ–**: 90% æ€§èƒ½æå‡
- **å†…å­˜ä½¿ç”¨**: < 100MB (1000ä¸ªå®ä½“)

### ä¸ç°æœ‰æ–¹æ¡ˆå¯¹æ¯”
| åŠŸèƒ½ | æ‰‹å†™ä»£ç  | åŸºäºç¬¬ä¸‰æ–¹åº“ | æ€§èƒ½æå‡ | ç»´æŠ¤æ€§æå‡ |
|------|---------|-------------|---------|-----------|
| ZodéªŒè¯ | ~1000è¡Œ | ~200è¡Œ | 80% | 95% |
| TSä»£ç ç”Ÿæˆ | ~800è¡Œ | ~150è¡Œ | 85% | 90% |
| å·®å¼‚æ£€æµ‹ | ~600è¡Œ | ~50è¡Œ | 92% | 95% |
| å›½é™…åŒ– | ~400è¡Œ | ~80è¡Œ | 80% | 90% |

---

**æ€»ç»“**: @linch-kit/schema é€šè¿‡åˆç†ä½¿ç”¨æˆç†Ÿçš„ç¬¬ä¸‰æ–¹åº“ï¼ˆZodã€ts-morphã€deep-diffç­‰ï¼‰ï¼Œé¿å…äº†é‡å¤é€ è½®å­ï¼ŒåŒæ—¶ä¿æŒäº†é«˜åº¦çš„å¯æ‰©å±•æ€§å’Œç±»å‹å®‰å…¨æ€§ã€‚